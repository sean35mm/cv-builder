"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@convex-dev";
exports.ids = ["vendor-chunks/@convex-dev"];
exports.modules = {

/***/ "(ssr)/./node_modules/@convex-dev/auth/dist/react/client.js":
/*!************************************************************!*\
  !*** ./node_modules/@convex-dev/auth/dist/react/client.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthProvider: () => (/* binding */ AuthProvider),\n/* harmony export */   ConvexAuthActionsContext: () => (/* binding */ ConvexAuthActionsContext),\n/* harmony export */   ConvexAuthTokenContext: () => (/* binding */ ConvexAuthTokenContext),\n/* harmony export */   useAuth: () => (/* binding */ useAuth)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n\n\nconst ConvexAuthActionsContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nconst ConvexAuthInternalContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nfunction useAuth() {\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(ConvexAuthInternalContext);\n}\nconst ConvexAuthTokenContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\nconst VERIFIER_STORAGE_KEY = \"__convexAuthOAuthVerifier\";\nconst JWT_STORAGE_KEY = \"__convexAuthJWT\";\nconst REFRESH_TOKEN_STORAGE_KEY = \"__convexAuthRefreshToken\";\nconst SERVER_STATE_FETCH_TIME_STORAGE_KEY = \"__convexAuthServerStateFetchTime\";\nfunction AuthProvider({ client, serverState, onChange, storage, storageNamespace, replaceURL, children, }) {\n    const token = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(serverState?._state.token ?? null);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(token.current === null);\n    const [tokenState, setTokenState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(token.current);\n    const verbose = client.verbose ?? false;\n    const logVerbose = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((message) => {\n        if (verbose) {\n            console.debug(`${new Date().toISOString()} ${message}`);\n        }\n    }, [verbose]);\n    const { storageSet, storageGet, storageRemove, storageKey } = useNamespacedStorage(storage, storageNamespace);\n    const [isRefreshingToken, setIsRefreshingToken] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const setToken = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async (args) => {\n        const wasAuthenticated = token.current !== null;\n        let newToken;\n        if (args.tokens === null) {\n            token.current = null;\n            if (args.shouldStore) {\n                await storageRemove(JWT_STORAGE_KEY);\n                await storageRemove(REFRESH_TOKEN_STORAGE_KEY);\n            }\n            newToken = null;\n        }\n        else {\n            const { token: value } = args.tokens;\n            token.current = value;\n            if (args.shouldStore) {\n                const { refreshToken } = args.tokens;\n                await storageSet(JWT_STORAGE_KEY, value);\n                await storageSet(REFRESH_TOKEN_STORAGE_KEY, refreshToken);\n            }\n            newToken = value;\n        }\n        if (wasAuthenticated !== (newToken !== null)) {\n            await onChange?.();\n        }\n        setTokenState(newToken);\n        setIsLoading(false);\n    }, [storageSet, storageRemove]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n        const listener = async (e) => {\n            if (isRefreshingToken) {\n                // There are 3 different ways to trigger this pop up so just try all of\n                // them.\n                e.preventDefault();\n                // This confirmation message doesn't actually appear in most modern\n                // browsers but we tried.\n                const confirmationMessage = \"Are you sure you want to leave? Your changes may not be saved.\";\n                e.returnValue = true;\n                return confirmationMessage;\n            }\n        };\n        browserAddEventListener(\"beforeunload\", listener);\n        return () => {\n            browserRemoveEventListener(\"beforeunload\", listener);\n        };\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n        // We're listening for:\n        // 1. sibling tabs in case of localStorage\n        // 2. other frames in case of sessionStorage\n        const listener = (event) => {\n            void (async () => {\n                // TODO: Test this if statement works in iframes correctly\n                if (event.storageArea !== storage) {\n                    return;\n                }\n                // Another tab/frame set the access token, use it\n                if (event.key === storageKey(JWT_STORAGE_KEY)) {\n                    const value = event.newValue;\n                    logVerbose(`synced access token, is null: ${value === null}`);\n                    // We don't write into storage since the event came from there and\n                    // we'd trigger a loop, plus we get each key as a separate event so\n                    // we don't have the refresh key here.\n                    await setToken({\n                        shouldStore: false,\n                        tokens: value === null ? null : { token: value },\n                    });\n                }\n            })();\n        };\n        browserAddEventListener(\"storage\", listener);\n        return () => browserRemoveEventListener(\"storage\", listener);\n    }, [setToken]);\n    const verifyCodeAndSetToken = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async (args) => {\n        const { tokens } = await client.unauthenticatedCall(\"auth:signIn\", \"code\" in args\n            ? { params: { code: args.code }, verifier: args.verifier }\n            : args);\n        logVerbose(`retrieved tokens, is null: ${tokens === null}`);\n        await setToken({ shouldStore: true, tokens: tokens ?? null });\n        return tokens !== null;\n    }, [client, setToken]);\n    const signIn = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async (provider, args) => {\n        const params = args instanceof FormData\n            ? Array.from(args.entries()).reduce((acc, [key, value]) => {\n                acc[key] = value;\n                return acc;\n            }, {})\n            : args ?? {};\n        const verifier = (await storageGet(VERIFIER_STORAGE_KEY)) ?? undefined;\n        await storageRemove(VERIFIER_STORAGE_KEY);\n        const result = await client.authenticatedCall(\"auth:signIn\", { provider, params, verifier });\n        if (result.redirect !== undefined) {\n            const url = new URL(result.redirect);\n            await storageSet(VERIFIER_STORAGE_KEY, result.verifier);\n            // Do not redirect in React Native\n            if (window.location !== undefined) {\n                window.location.href = url.toString();\n            }\n            return { signingIn: false, redirect: url };\n        }\n        else if (result.tokens !== undefined) {\n            const { tokens } = result;\n            logVerbose(`signed in and got tokens, is null: ${tokens === null}`);\n            await setToken({ shouldStore: true, tokens });\n            return { signingIn: result.tokens !== null };\n        }\n        return { signingIn: false };\n    }, [client, setToken, storageGet]);\n    const signOut = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async () => {\n        try {\n            await client.authenticatedCall(\"auth:signOut\");\n        }\n        catch (error) {\n            // Ignore any errors, they are usually caused by being\n            // already signed out, which is ok.\n        }\n        logVerbose(`signed out, erasing tokens`);\n        await setToken({ shouldStore: true, tokens: null });\n    }, [setToken, client]);\n    const fetchAccessToken = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async ({ forceRefreshToken }) => {\n        if (forceRefreshToken) {\n            const tokenBeforeLockAquisition = token.current;\n            return await browserMutex(REFRESH_TOKEN_STORAGE_KEY, async () => {\n                const tokenAfterLockAquisition = token.current;\n                // Another tab or frame just refreshed the token, we can use it\n                // and skip another refresh.\n                if (tokenAfterLockAquisition !== tokenBeforeLockAquisition) {\n                    logVerbose(`returning synced token, is null: ${tokenAfterLockAquisition === null}`);\n                    return tokenAfterLockAquisition;\n                }\n                const refreshToken = (await storageGet(REFRESH_TOKEN_STORAGE_KEY)) ?? null;\n                if (refreshToken !== null) {\n                    setIsRefreshingToken(true);\n                    await verifyCodeAndSetToken({ refreshToken }).finally(() => {\n                        setIsRefreshingToken(false);\n                    });\n                    logVerbose(`returning retrieved token, is null: ${tokenAfterLockAquisition === null}`);\n                    return token.current;\n                }\n                else {\n                    setIsRefreshingToken(false);\n                    logVerbose(`returning null, there is no refresh token`);\n                    return null;\n                }\n            });\n        }\n        return token.current;\n    }, [verifyCodeAndSetToken, signOut, storageGet]);\n    const signingInWithCodeFromURL = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n        // Has to happen in useEffect to avoid SSR.\n        if (storage === undefined) {\n            throw new Error(\"`localStorage` is not available in this environment, \" +\n                \"set the `storage` prop on `ConvexAuthProvider`!\");\n        }\n        const readStateFromStorage = async () => {\n            const token = (await storageGet(JWT_STORAGE_KEY)) ?? null;\n            logVerbose(`retrieved token from storage, is null: ${token === null}`);\n            await setToken({\n                shouldStore: false,\n                tokens: token === null ? null : { token },\n            });\n        };\n        if (serverState !== undefined) {\n            // First check that this isn't a subsequent render\n            // with stale serverState.\n            const timeFetched = storageGet(SERVER_STATE_FETCH_TIME_STORAGE_KEY);\n            const setTokensFromServerState = (timeFetched) => {\n                if (!timeFetched || serverState._timeFetched > +timeFetched) {\n                    const { token, refreshToken } = serverState._state;\n                    const tokens = token === null || refreshToken === null\n                        ? null\n                        : { token, refreshToken };\n                    void storageSet(SERVER_STATE_FETCH_TIME_STORAGE_KEY, serverState._timeFetched.toString());\n                    void setToken({ tokens, shouldStore: true });\n                }\n                else {\n                    void readStateFromStorage();\n                }\n            };\n            // We want to avoid async if possible.\n            if (timeFetched instanceof Promise) {\n                void timeFetched.then(setTokensFromServerState);\n            }\n            else {\n                setTokensFromServerState(timeFetched);\n            }\n            return;\n        }\n        const code = typeof window?.location !== \"undefined\"\n            ? new URLSearchParams(window.location.search).get(\"code\")\n            : null;\n        // code from URL is only consumed initially,\n        // ref avoids racing in Strict mode\n        if (signingInWithCodeFromURL.current || code) {\n            if (code && !signingInWithCodeFromURL.current) {\n                signingInWithCodeFromURL.current = true;\n                const url = new URL(window.location.href);\n                url.searchParams.delete(\"code\");\n                void (async () => {\n                    await replaceURL(url.pathname + url.search + url.hash);\n                    await signIn(undefined, { code });\n                    signingInWithCodeFromURL.current = false;\n                })();\n            }\n        }\n        else {\n            void readStateFromStorage();\n        }\n    }, \n    // Explicitly chosen dependencies.\n    // This effect should mostly only run once\n    // on mount.\n    [client, storageGet]);\n    const actions = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => ({ signIn, signOut }), [signIn, signOut]);\n    const isAuthenticated = tokenState !== null;\n    const authState = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => ({\n        isLoading,\n        isAuthenticated,\n        fetchAccessToken,\n    }), [fetchAccessToken, isLoading, isAuthenticated]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ConvexAuthInternalContext.Provider, { value: authState, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ConvexAuthActionsContext.Provider, { value: actions, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ConvexAuthTokenContext.Provider, { value: tokenState, children: children }) }) }));\n}\nfunction useNamespacedStorage(peristentStorage, namespace) {\n    const inMemoryStorage = useInMemoryStorage();\n    const storage = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => peristentStorage ?? inMemoryStorage(), [peristentStorage]);\n    const escapedNamespace = namespace.replace(/[^a-zA-Z0-9]/g, \"\");\n    const storageKey = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((key) => `${key}_${escapedNamespace}`, [namespace]);\n    const storageSet = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((key, value) => storage.setItem(storageKey(key), value), [storage, storageKey]);\n    const storageGet = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((key) => storage.getItem(storageKey(key)), [storage, storageKey]);\n    const storageRemove = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((key) => storage.removeItem(storageKey(key)), [storage, storageKey]);\n    return { storageSet, storageGet, storageRemove, storageKey };\n}\nfunction useInMemoryStorage() {\n    const [inMemoryStorage, setInMemoryStorage] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    return () => ({\n        getItem: (key) => inMemoryStorage[key],\n        setItem: (key, value) => {\n            setInMemoryStorage((prev) => ({ ...prev, [key]: value }));\n        },\n        removeItem: (key) => {\n            setInMemoryStorage((prev) => {\n                const { [key]: _, ...rest } = prev;\n                return rest;\n            });\n        },\n    });\n}\n// In the browser, executes the callback as the only tab / frame at a time.\nasync function browserMutex(key, callback) {\n    const lockManager = window?.navigator?.locks;\n    return lockManager !== undefined\n        ? await lockManager.request(key, callback)\n        : await manualMutex(key, callback);\n}\nfunction getMutexValue(key) {\n    if (globalThis.__convexAuthMutexes === undefined) {\n        globalThis.__convexAuthMutexes = {};\n    }\n    let mutex = globalThis.__convexAuthMutexes[key];\n    if (mutex === undefined) {\n        globalThis.__convexAuthMutexes[key] = {\n            currentlyRunning: null,\n            waiting: [],\n        };\n    }\n    mutex = globalThis.__convexAuthMutexes[key];\n    return mutex;\n}\nfunction setMutexValue(key, value) {\n    globalThis.__convexAuthMutexes[key] = value;\n}\nasync function enqueueCallbackForMutex(key, callback) {\n    const mutex = getMutexValue(key);\n    if (mutex.currentlyRunning === null) {\n        setMutexValue(key, {\n            currentlyRunning: callback().finally(() => {\n                const nextCb = getMutexValue(key).waiting.shift();\n                getMutexValue(key).currentlyRunning = null;\n                setMutexValue(key, {\n                    ...getMutexValue(key),\n                    currentlyRunning: nextCb === undefined ? null : enqueueCallbackForMutex(key, nextCb),\n                });\n            }),\n            waiting: [],\n        });\n    }\n    else {\n        setMutexValue(key, {\n            ...mutex,\n            waiting: [...mutex.waiting, callback],\n        });\n    }\n}\nasync function manualMutex(key, callback) {\n    const outerPromise = new Promise((resolve, reject) => {\n        const wrappedCallback = () => {\n            return callback()\n                .then((v) => resolve(v))\n                .catch((e) => reject(e));\n        };\n        void enqueueCallbackForMutex(key, wrappedCallback);\n    });\n    return outerPromise;\n}\nfunction browserAddEventListener(type, listener, options) {\n    window.addEventListener?.(type, listener, options);\n}\nfunction browserRemoveEventListener(type, listener, options) {\n    window.removeEventListener?.(type, listener, options);\n}\n//# sourceMappingURL=client.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvbnZleC1kZXYvYXV0aC9kaXN0L3JlYWN0L2NsaWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBZ0Q7QUFDc0Q7QUFDL0YsaUNBQWlDLG9EQUFhO0FBQ3JELGtDQUFrQyxvREFBYTtBQUN4QztBQUNQLFdBQVcsaURBQVU7QUFDckI7QUFDTywrQkFBK0Isb0RBQWE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDTyx3QkFBd0IsaUZBQWlGO0FBQ2hILGtCQUFrQiw2Q0FBTTtBQUN4QixzQ0FBc0MsK0NBQVE7QUFDOUMsd0NBQXdDLCtDQUFRO0FBQ2hEO0FBQ0EsdUJBQXVCLGtEQUFXO0FBQ2xDO0FBQ0EsNkJBQTZCLDBCQUEwQixFQUFFLFFBQVE7QUFDakU7QUFDQSxLQUFLO0FBQ0wsWUFBWSxvREFBb0Q7QUFDaEUsc0RBQXNELCtDQUFRO0FBQzlELHFCQUFxQixrREFBVztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGVBQWU7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxjQUFjO0FBQ3hFLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsa0NBQWtDLGtEQUFX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Q0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3NlYW5naWwvRGVza3RvcC9DaGVmIENWIEJ1aWxkZXIvbm9kZV9tb2R1bGVzL0Bjb252ZXgtZGV2L2F1dGgvZGlzdC9yZWFjdC9jbGllbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsganN4IGFzIF9qc3ggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNhbGxiYWNrLCB1c2VDb250ZXh0LCB1c2VFZmZlY3QsIHVzZU1lbW8sIHVzZVJlZiwgdXNlU3RhdGUsIH0gZnJvbSBcInJlYWN0XCI7XG5leHBvcnQgY29uc3QgQ29udmV4QXV0aEFjdGlvbnNDb250ZXh0ID0gY3JlYXRlQ29udGV4dCh1bmRlZmluZWQpO1xuY29uc3QgQ29udmV4QXV0aEludGVybmFsQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQodW5kZWZpbmVkKTtcbmV4cG9ydCBmdW5jdGlvbiB1c2VBdXRoKCkge1xuICAgIHJldHVybiB1c2VDb250ZXh0KENvbnZleEF1dGhJbnRlcm5hbENvbnRleHQpO1xufVxuZXhwb3J0IGNvbnN0IENvbnZleEF1dGhUb2tlbkNvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwpO1xuY29uc3QgVkVSSUZJRVJfU1RPUkFHRV9LRVkgPSBcIl9fY29udmV4QXV0aE9BdXRoVmVyaWZpZXJcIjtcbmNvbnN0IEpXVF9TVE9SQUdFX0tFWSA9IFwiX19jb252ZXhBdXRoSldUXCI7XG5jb25zdCBSRUZSRVNIX1RPS0VOX1NUT1JBR0VfS0VZID0gXCJfX2NvbnZleEF1dGhSZWZyZXNoVG9rZW5cIjtcbmNvbnN0IFNFUlZFUl9TVEFURV9GRVRDSF9USU1FX1NUT1JBR0VfS0VZID0gXCJfX2NvbnZleEF1dGhTZXJ2ZXJTdGF0ZUZldGNoVGltZVwiO1xuZXhwb3J0IGZ1bmN0aW9uIEF1dGhQcm92aWRlcih7IGNsaWVudCwgc2VydmVyU3RhdGUsIG9uQ2hhbmdlLCBzdG9yYWdlLCBzdG9yYWdlTmFtZXNwYWNlLCByZXBsYWNlVVJMLCBjaGlsZHJlbiwgfSkge1xuICAgIGNvbnN0IHRva2VuID0gdXNlUmVmKHNlcnZlclN0YXRlPy5fc3RhdGUudG9rZW4gPz8gbnVsbCk7XG4gICAgY29uc3QgW2lzTG9hZGluZywgc2V0SXNMb2FkaW5nXSA9IHVzZVN0YXRlKHRva2VuLmN1cnJlbnQgPT09IG51bGwpO1xuICAgIGNvbnN0IFt0b2tlblN0YXRlLCBzZXRUb2tlblN0YXRlXSA9IHVzZVN0YXRlKHRva2VuLmN1cnJlbnQpO1xuICAgIGNvbnN0IHZlcmJvc2UgPSBjbGllbnQudmVyYm9zZSA/PyBmYWxzZTtcbiAgICBjb25zdCBsb2dWZXJib3NlID0gdXNlQ2FsbGJhY2soKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgaWYgKHZlcmJvc2UpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoYCR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpfSAke21lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICB9LCBbdmVyYm9zZV0pO1xuICAgIGNvbnN0IHsgc3RvcmFnZVNldCwgc3RvcmFnZUdldCwgc3RvcmFnZVJlbW92ZSwgc3RvcmFnZUtleSB9ID0gdXNlTmFtZXNwYWNlZFN0b3JhZ2Uoc3RvcmFnZSwgc3RvcmFnZU5hbWVzcGFjZSk7XG4gICAgY29uc3QgW2lzUmVmcmVzaGluZ1Rva2VuLCBzZXRJc1JlZnJlc2hpbmdUb2tlbl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3Qgc2V0VG9rZW4gPSB1c2VDYWxsYmFjayhhc3luYyAoYXJncykgPT4ge1xuICAgICAgICBjb25zdCB3YXNBdXRoZW50aWNhdGVkID0gdG9rZW4uY3VycmVudCAhPT0gbnVsbDtcbiAgICAgICAgbGV0IG5ld1Rva2VuO1xuICAgICAgICBpZiAoYXJncy50b2tlbnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRva2VuLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGFyZ3Muc2hvdWxkU3RvcmUpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBzdG9yYWdlUmVtb3ZlKEpXVF9TVE9SQUdFX0tFWSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgc3RvcmFnZVJlbW92ZShSRUZSRVNIX1RPS0VOX1NUT1JBR0VfS0VZKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld1Rva2VuID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdG9rZW46IHZhbHVlIH0gPSBhcmdzLnRva2VucztcbiAgICAgICAgICAgIHRva2VuLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChhcmdzLnNob3VsZFN0b3JlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyByZWZyZXNoVG9rZW4gfSA9IGFyZ3MudG9rZW5zO1xuICAgICAgICAgICAgICAgIGF3YWl0IHN0b3JhZ2VTZXQoSldUX1NUT1JBR0VfS0VZLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgc3RvcmFnZVNldChSRUZSRVNIX1RPS0VOX1NUT1JBR0VfS0VZLCByZWZyZXNoVG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3VG9rZW4gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod2FzQXV0aGVudGljYXRlZCAhPT0gKG5ld1Rva2VuICE9PSBudWxsKSkge1xuICAgICAgICAgICAgYXdhaXQgb25DaGFuZ2U/LigpO1xuICAgICAgICB9XG4gICAgICAgIHNldFRva2VuU3RhdGUobmV3VG9rZW4pO1xuICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgIH0sIFtzdG9yYWdlU2V0LCBzdG9yYWdlUmVtb3ZlXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgbGlzdGVuZXIgPSBhc3luYyAoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzUmVmcmVzaGluZ1Rva2VuKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlcmUgYXJlIDMgZGlmZmVyZW50IHdheXMgdG8gdHJpZ2dlciB0aGlzIHBvcCB1cCBzbyBqdXN0IHRyeSBhbGwgb2ZcbiAgICAgICAgICAgICAgICAvLyB0aGVtLlxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNvbmZpcm1hdGlvbiBtZXNzYWdlIGRvZXNuJ3QgYWN0dWFsbHkgYXBwZWFyIGluIG1vc3QgbW9kZXJuXG4gICAgICAgICAgICAgICAgLy8gYnJvd3NlcnMgYnV0IHdlIHRyaWVkLlxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbmZpcm1hdGlvbk1lc3NhZ2UgPSBcIkFyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBsZWF2ZT8gWW91ciBjaGFuZ2VzIG1heSBub3QgYmUgc2F2ZWQuXCI7XG4gICAgICAgICAgICAgICAgZS5yZXR1cm5WYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbmZpcm1hdGlvbk1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGJyb3dzZXJBZGRFdmVudExpc3RlbmVyKFwiYmVmb3JldW5sb2FkXCIsIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGJyb3dzZXJSZW1vdmVFdmVudExpc3RlbmVyKFwiYmVmb3JldW5sb2FkXCIsIGxpc3RlbmVyKTtcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAvLyBXZSdyZSBsaXN0ZW5pbmcgZm9yOlxuICAgICAgICAvLyAxLiBzaWJsaW5nIHRhYnMgaW4gY2FzZSBvZiBsb2NhbFN0b3JhZ2VcbiAgICAgICAgLy8gMi4gb3RoZXIgZnJhbWVzIGluIGNhc2Ugb2Ygc2Vzc2lvblN0b3JhZ2VcbiAgICAgICAgY29uc3QgbGlzdGVuZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHZvaWQgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBUZXN0IHRoaXMgaWYgc3RhdGVtZW50IHdvcmtzIGluIGlmcmFtZXMgY29ycmVjdGx5XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnN0b3JhZ2VBcmVhICE9PSBzdG9yYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQW5vdGhlciB0YWIvZnJhbWUgc2V0IHRoZSBhY2Nlc3MgdG9rZW4sIHVzZSBpdFxuICAgICAgICAgICAgICAgIGlmIChldmVudC5rZXkgPT09IHN0b3JhZ2VLZXkoSldUX1NUT1JBR0VfS0VZKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGV2ZW50Lm5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBsb2dWZXJib3NlKGBzeW5jZWQgYWNjZXNzIHRva2VuLCBpcyBudWxsOiAke3ZhbHVlID09PSBudWxsfWApO1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCB3cml0ZSBpbnRvIHN0b3JhZ2Ugc2luY2UgdGhlIGV2ZW50IGNhbWUgZnJvbSB0aGVyZSBhbmRcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UnZCB0cmlnZ2VyIGEgbG9vcCwgcGx1cyB3ZSBnZXQgZWFjaCBrZXkgYXMgYSBzZXBhcmF0ZSBldmVudCBzb1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBkb24ndCBoYXZlIHRoZSByZWZyZXNoIGtleSBoZXJlLlxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBzZXRUb2tlbih7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRTdG9yZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnM6IHZhbHVlID09PSBudWxsID8gbnVsbCA6IHsgdG9rZW46IHZhbHVlIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIH07XG4gICAgICAgIGJyb3dzZXJBZGRFdmVudExpc3RlbmVyKFwic3RvcmFnZVwiLCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiAoKSA9PiBicm93c2VyUmVtb3ZlRXZlbnRMaXN0ZW5lcihcInN0b3JhZ2VcIiwgbGlzdGVuZXIpO1xuICAgIH0sIFtzZXRUb2tlbl0pO1xuICAgIGNvbnN0IHZlcmlmeUNvZGVBbmRTZXRUb2tlbiA9IHVzZUNhbGxiYWNrKGFzeW5jIChhcmdzKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgdG9rZW5zIH0gPSBhd2FpdCBjbGllbnQudW5hdXRoZW50aWNhdGVkQ2FsbChcImF1dGg6c2lnbkluXCIsIFwiY29kZVwiIGluIGFyZ3NcbiAgICAgICAgICAgID8geyBwYXJhbXM6IHsgY29kZTogYXJncy5jb2RlIH0sIHZlcmlmaWVyOiBhcmdzLnZlcmlmaWVyIH1cbiAgICAgICAgICAgIDogYXJncyk7XG4gICAgICAgIGxvZ1ZlcmJvc2UoYHJldHJpZXZlZCB0b2tlbnMsIGlzIG51bGw6ICR7dG9rZW5zID09PSBudWxsfWApO1xuICAgICAgICBhd2FpdCBzZXRUb2tlbih7IHNob3VsZFN0b3JlOiB0cnVlLCB0b2tlbnM6IHRva2VucyA/PyBudWxsIH0pO1xuICAgICAgICByZXR1cm4gdG9rZW5zICE9PSBudWxsO1xuICAgIH0sIFtjbGllbnQsIHNldFRva2VuXSk7XG4gICAgY29uc3Qgc2lnbkluID0gdXNlQ2FsbGJhY2soYXN5bmMgKHByb3ZpZGVyLCBhcmdzKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IGFyZ3MgaW5zdGFuY2VvZiBGb3JtRGF0YVxuICAgICAgICAgICAgPyBBcnJheS5mcm9tKGFyZ3MuZW50cmllcygpKS5yZWR1Y2UoKGFjYywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgYWNjW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSwge30pXG4gICAgICAgICAgICA6IGFyZ3MgPz8ge307XG4gICAgICAgIGNvbnN0IHZlcmlmaWVyID0gKGF3YWl0IHN0b3JhZ2VHZXQoVkVSSUZJRVJfU1RPUkFHRV9LRVkpKSA/PyB1bmRlZmluZWQ7XG4gICAgICAgIGF3YWl0IHN0b3JhZ2VSZW1vdmUoVkVSSUZJRVJfU1RPUkFHRV9LRVkpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjbGllbnQuYXV0aGVudGljYXRlZENhbGwoXCJhdXRoOnNpZ25JblwiLCB7IHByb3ZpZGVyLCBwYXJhbXMsIHZlcmlmaWVyIH0pO1xuICAgICAgICBpZiAocmVzdWx0LnJlZGlyZWN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwocmVzdWx0LnJlZGlyZWN0KTtcbiAgICAgICAgICAgIGF3YWl0IHN0b3JhZ2VTZXQoVkVSSUZJRVJfU1RPUkFHRV9LRVksIHJlc3VsdC52ZXJpZmllcik7XG4gICAgICAgICAgICAvLyBEbyBub3QgcmVkaXJlY3QgaW4gUmVhY3QgTmF0aXZlXG4gICAgICAgICAgICBpZiAod2luZG93LmxvY2F0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHVybC50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgc2lnbmluZ0luOiBmYWxzZSwgcmVkaXJlY3Q6IHVybCB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlc3VsdC50b2tlbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgeyB0b2tlbnMgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgIGxvZ1ZlcmJvc2UoYHNpZ25lZCBpbiBhbmQgZ290IHRva2VucywgaXMgbnVsbDogJHt0b2tlbnMgPT09IG51bGx9YCk7XG4gICAgICAgICAgICBhd2FpdCBzZXRUb2tlbih7IHNob3VsZFN0b3JlOiB0cnVlLCB0b2tlbnMgfSk7XG4gICAgICAgICAgICByZXR1cm4geyBzaWduaW5nSW46IHJlc3VsdC50b2tlbnMgIT09IG51bGwgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzaWduaW5nSW46IGZhbHNlIH07XG4gICAgfSwgW2NsaWVudCwgc2V0VG9rZW4sIHN0b3JhZ2VHZXRdKTtcbiAgICBjb25zdCBzaWduT3V0ID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgY2xpZW50LmF1dGhlbnRpY2F0ZWRDYWxsKFwiYXV0aDpzaWduT3V0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gSWdub3JlIGFueSBlcnJvcnMsIHRoZXkgYXJlIHVzdWFsbHkgY2F1c2VkIGJ5IGJlaW5nXG4gICAgICAgICAgICAvLyBhbHJlYWR5IHNpZ25lZCBvdXQsIHdoaWNoIGlzIG9rLlxuICAgICAgICB9XG4gICAgICAgIGxvZ1ZlcmJvc2UoYHNpZ25lZCBvdXQsIGVyYXNpbmcgdG9rZW5zYCk7XG4gICAgICAgIGF3YWl0IHNldFRva2VuKHsgc2hvdWxkU3RvcmU6IHRydWUsIHRva2VuczogbnVsbCB9KTtcbiAgICB9LCBbc2V0VG9rZW4sIGNsaWVudF0pO1xuICAgIGNvbnN0IGZldGNoQWNjZXNzVG9rZW4gPSB1c2VDYWxsYmFjayhhc3luYyAoeyBmb3JjZVJlZnJlc2hUb2tlbiB9KSA9PiB7XG4gICAgICAgIGlmIChmb3JjZVJlZnJlc2hUb2tlbikge1xuICAgICAgICAgICAgY29uc3QgdG9rZW5CZWZvcmVMb2NrQXF1aXNpdGlvbiA9IHRva2VuLmN1cnJlbnQ7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgYnJvd3Nlck11dGV4KFJFRlJFU0hfVE9LRU5fU1RPUkFHRV9LRVksIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b2tlbkFmdGVyTG9ja0FxdWlzaXRpb24gPSB0b2tlbi5jdXJyZW50O1xuICAgICAgICAgICAgICAgIC8vIEFub3RoZXIgdGFiIG9yIGZyYW1lIGp1c3QgcmVmcmVzaGVkIHRoZSB0b2tlbiwgd2UgY2FuIHVzZSBpdFxuICAgICAgICAgICAgICAgIC8vIGFuZCBza2lwIGFub3RoZXIgcmVmcmVzaC5cbiAgICAgICAgICAgICAgICBpZiAodG9rZW5BZnRlckxvY2tBcXVpc2l0aW9uICE9PSB0b2tlbkJlZm9yZUxvY2tBcXVpc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ1ZlcmJvc2UoYHJldHVybmluZyBzeW5jZWQgdG9rZW4sIGlzIG51bGw6ICR7dG9rZW5BZnRlckxvY2tBcXVpc2l0aW9uID09PSBudWxsfWApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5BZnRlckxvY2tBcXVpc2l0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZWZyZXNoVG9rZW4gPSAoYXdhaXQgc3RvcmFnZUdldChSRUZSRVNIX1RPS0VOX1NUT1JBR0VfS0VZKSkgPz8gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAocmVmcmVzaFRva2VuICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldElzUmVmcmVzaGluZ1Rva2VuKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB2ZXJpZnlDb2RlQW5kU2V0VG9rZW4oeyByZWZyZXNoVG9rZW4gfSkuZmluYWxseSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRJc1JlZnJlc2hpbmdUb2tlbihmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBsb2dWZXJib3NlKGByZXR1cm5pbmcgcmV0cmlldmVkIHRva2VuLCBpcyBudWxsOiAke3Rva2VuQWZ0ZXJMb2NrQXF1aXNpdGlvbiA9PT0gbnVsbH1gKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXRJc1JlZnJlc2hpbmdUb2tlbihmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGxvZ1ZlcmJvc2UoYHJldHVybmluZyBudWxsLCB0aGVyZSBpcyBubyByZWZyZXNoIHRva2VuYCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlbi5jdXJyZW50O1xuICAgIH0sIFt2ZXJpZnlDb2RlQW5kU2V0VG9rZW4sIHNpZ25PdXQsIHN0b3JhZ2VHZXRdKTtcbiAgICBjb25zdCBzaWduaW5nSW5XaXRoQ29kZUZyb21VUkwgPSB1c2VSZWYoZmFsc2UpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIC8vIEhhcyB0byBoYXBwZW4gaW4gdXNlRWZmZWN0IHRvIGF2b2lkIFNTUi5cbiAgICAgICAgaWYgKHN0b3JhZ2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYGxvY2FsU3RvcmFnZWAgaXMgbm90IGF2YWlsYWJsZSBpbiB0aGlzIGVudmlyb25tZW50LCBcIiArXG4gICAgICAgICAgICAgICAgXCJzZXQgdGhlIGBzdG9yYWdlYCBwcm9wIG9uIGBDb252ZXhBdXRoUHJvdmlkZXJgIVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZWFkU3RhdGVGcm9tU3RvcmFnZSA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuID0gKGF3YWl0IHN0b3JhZ2VHZXQoSldUX1NUT1JBR0VfS0VZKSkgPz8gbnVsbDtcbiAgICAgICAgICAgIGxvZ1ZlcmJvc2UoYHJldHJpZXZlZCB0b2tlbiBmcm9tIHN0b3JhZ2UsIGlzIG51bGw6ICR7dG9rZW4gPT09IG51bGx9YCk7XG4gICAgICAgICAgICBhd2FpdCBzZXRUb2tlbih7XG4gICAgICAgICAgICAgICAgc2hvdWxkU3RvcmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHRva2VuczogdG9rZW4gPT09IG51bGwgPyBudWxsIDogeyB0b2tlbiB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChzZXJ2ZXJTdGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBGaXJzdCBjaGVjayB0aGF0IHRoaXMgaXNuJ3QgYSBzdWJzZXF1ZW50IHJlbmRlclxuICAgICAgICAgICAgLy8gd2l0aCBzdGFsZSBzZXJ2ZXJTdGF0ZS5cbiAgICAgICAgICAgIGNvbnN0IHRpbWVGZXRjaGVkID0gc3RvcmFnZUdldChTRVJWRVJfU1RBVEVfRkVUQ0hfVElNRV9TVE9SQUdFX0tFWSk7XG4gICAgICAgICAgICBjb25zdCBzZXRUb2tlbnNGcm9tU2VydmVyU3RhdGUgPSAodGltZUZldGNoZWQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRpbWVGZXRjaGVkIHx8IHNlcnZlclN0YXRlLl90aW1lRmV0Y2hlZCA+ICt0aW1lRmV0Y2hlZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHRva2VuLCByZWZyZXNoVG9rZW4gfSA9IHNlcnZlclN0YXRlLl9zdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9rZW5zID0gdG9rZW4gPT09IG51bGwgfHwgcmVmcmVzaFRva2VuID09PSBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgIDogeyB0b2tlbiwgcmVmcmVzaFRva2VuIH07XG4gICAgICAgICAgICAgICAgICAgIHZvaWQgc3RvcmFnZVNldChTRVJWRVJfU1RBVEVfRkVUQ0hfVElNRV9TVE9SQUdFX0tFWSwgc2VydmVyU3RhdGUuX3RpbWVGZXRjaGVkLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICB2b2lkIHNldFRva2VuKHsgdG9rZW5zLCBzaG91bGRTdG9yZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZvaWQgcmVhZFN0YXRlRnJvbVN0b3JhZ2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gV2Ugd2FudCB0byBhdm9pZCBhc3luYyBpZiBwb3NzaWJsZS5cbiAgICAgICAgICAgIGlmICh0aW1lRmV0Y2hlZCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICB2b2lkIHRpbWVGZXRjaGVkLnRoZW4oc2V0VG9rZW5zRnJvbVNlcnZlclN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldFRva2Vuc0Zyb21TZXJ2ZXJTdGF0ZSh0aW1lRmV0Y2hlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29kZSA9IHR5cGVvZiB3aW5kb3c/LmxvY2F0aW9uICE9PSBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICA/IG5ldyBVUkxTZWFyY2hQYXJhbXMod2luZG93LmxvY2F0aW9uLnNlYXJjaCkuZ2V0KFwiY29kZVwiKVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAvLyBjb2RlIGZyb20gVVJMIGlzIG9ubHkgY29uc3VtZWQgaW5pdGlhbGx5LFxuICAgICAgICAvLyByZWYgYXZvaWRzIHJhY2luZyBpbiBTdHJpY3QgbW9kZVxuICAgICAgICBpZiAoc2lnbmluZ0luV2l0aENvZGVGcm9tVVJMLmN1cnJlbnQgfHwgY29kZSkge1xuICAgICAgICAgICAgaWYgKGNvZGUgJiYgIXNpZ25pbmdJbldpdGhDb2RlRnJvbVVSTC5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgc2lnbmluZ0luV2l0aENvZGVGcm9tVVJMLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuZGVsZXRlKFwiY29kZVwiKTtcbiAgICAgICAgICAgICAgICB2b2lkIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHJlcGxhY2VVUkwodXJsLnBhdGhuYW1lICsgdXJsLnNlYXJjaCArIHVybC5oYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgc2lnbkluKHVuZGVmaW5lZCwgeyBjb2RlIH0pO1xuICAgICAgICAgICAgICAgICAgICBzaWduaW5nSW5XaXRoQ29kZUZyb21VUkwuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2b2lkIHJlYWRTdGF0ZUZyb21TdG9yYWdlKCk7XG4gICAgICAgIH1cbiAgICB9LCBcbiAgICAvLyBFeHBsaWNpdGx5IGNob3NlbiBkZXBlbmRlbmNpZXMuXG4gICAgLy8gVGhpcyBlZmZlY3Qgc2hvdWxkIG1vc3RseSBvbmx5IHJ1biBvbmNlXG4gICAgLy8gb24gbW91bnQuXG4gICAgW2NsaWVudCwgc3RvcmFnZUdldF0pO1xuICAgIGNvbnN0IGFjdGlvbnMgPSB1c2VNZW1vKCgpID0+ICh7IHNpZ25Jbiwgc2lnbk91dCB9KSwgW3NpZ25Jbiwgc2lnbk91dF0pO1xuICAgIGNvbnN0IGlzQXV0aGVudGljYXRlZCA9IHRva2VuU3RhdGUgIT09IG51bGw7XG4gICAgY29uc3QgYXV0aFN0YXRlID0gdXNlTWVtbygoKSA9PiAoe1xuICAgICAgICBpc0xvYWRpbmcsXG4gICAgICAgIGlzQXV0aGVudGljYXRlZCxcbiAgICAgICAgZmV0Y2hBY2Nlc3NUb2tlbixcbiAgICB9KSwgW2ZldGNoQWNjZXNzVG9rZW4sIGlzTG9hZGluZywgaXNBdXRoZW50aWNhdGVkXSk7XG4gICAgcmV0dXJuIChfanN4KENvbnZleEF1dGhJbnRlcm5hbENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGF1dGhTdGF0ZSwgY2hpbGRyZW46IF9qc3goQ29udmV4QXV0aEFjdGlvbnNDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBhY3Rpb25zLCBjaGlsZHJlbjogX2pzeChDb252ZXhBdXRoVG9rZW5Db250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB0b2tlblN0YXRlLCBjaGlsZHJlbjogY2hpbGRyZW4gfSkgfSkgfSkpO1xufVxuZnVuY3Rpb24gdXNlTmFtZXNwYWNlZFN0b3JhZ2UocGVyaXN0ZW50U3RvcmFnZSwgbmFtZXNwYWNlKSB7XG4gICAgY29uc3QgaW5NZW1vcnlTdG9yYWdlID0gdXNlSW5NZW1vcnlTdG9yYWdlKCk7XG4gICAgY29uc3Qgc3RvcmFnZSA9IHVzZU1lbW8oKCkgPT4gcGVyaXN0ZW50U3RvcmFnZSA/PyBpbk1lbW9yeVN0b3JhZ2UoKSwgW3BlcmlzdGVudFN0b3JhZ2VdKTtcbiAgICBjb25zdCBlc2NhcGVkTmFtZXNwYWNlID0gbmFtZXNwYWNlLnJlcGxhY2UoL1teYS16QS1aMC05XS9nLCBcIlwiKTtcbiAgICBjb25zdCBzdG9yYWdlS2V5ID0gdXNlQ2FsbGJhY2soKGtleSkgPT4gYCR7a2V5fV8ke2VzY2FwZWROYW1lc3BhY2V9YCwgW25hbWVzcGFjZV0pO1xuICAgIGNvbnN0IHN0b3JhZ2VTZXQgPSB1c2VDYWxsYmFjaygoa2V5LCB2YWx1ZSkgPT4gc3RvcmFnZS5zZXRJdGVtKHN0b3JhZ2VLZXkoa2V5KSwgdmFsdWUpLCBbc3RvcmFnZSwgc3RvcmFnZUtleV0pO1xuICAgIGNvbnN0IHN0b3JhZ2VHZXQgPSB1c2VDYWxsYmFjaygoa2V5KSA9PiBzdG9yYWdlLmdldEl0ZW0oc3RvcmFnZUtleShrZXkpKSwgW3N0b3JhZ2UsIHN0b3JhZ2VLZXldKTtcbiAgICBjb25zdCBzdG9yYWdlUmVtb3ZlID0gdXNlQ2FsbGJhY2soKGtleSkgPT4gc3RvcmFnZS5yZW1vdmVJdGVtKHN0b3JhZ2VLZXkoa2V5KSksIFtzdG9yYWdlLCBzdG9yYWdlS2V5XSk7XG4gICAgcmV0dXJuIHsgc3RvcmFnZVNldCwgc3RvcmFnZUdldCwgc3RvcmFnZVJlbW92ZSwgc3RvcmFnZUtleSB9O1xufVxuZnVuY3Rpb24gdXNlSW5NZW1vcnlTdG9yYWdlKCkge1xuICAgIGNvbnN0IFtpbk1lbW9yeVN0b3JhZ2UsIHNldEluTWVtb3J5U3RvcmFnZV0gPSB1c2VTdGF0ZSh7fSk7XG4gICAgcmV0dXJuICgpID0+ICh7XG4gICAgICAgIGdldEl0ZW06IChrZXkpID0+IGluTWVtb3J5U3RvcmFnZVtrZXldLFxuICAgICAgICBzZXRJdGVtOiAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgc2V0SW5NZW1vcnlTdG9yYWdlKChwcmV2KSA9PiAoeyAuLi5wcmV2LCBba2V5XTogdmFsdWUgfSkpO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmVJdGVtOiAoa2V5KSA9PiB7XG4gICAgICAgICAgICBzZXRJbk1lbW9yeVN0b3JhZ2UoKHByZXYpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IFtrZXldOiBfLCAuLi5yZXN0IH0gPSBwcmV2O1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vLyBJbiB0aGUgYnJvd3NlciwgZXhlY3V0ZXMgdGhlIGNhbGxiYWNrIGFzIHRoZSBvbmx5IHRhYiAvIGZyYW1lIGF0IGEgdGltZS5cbmFzeW5jIGZ1bmN0aW9uIGJyb3dzZXJNdXRleChrZXksIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgbG9ja01hbmFnZXIgPSB3aW5kb3c/Lm5hdmlnYXRvcj8ubG9ja3M7XG4gICAgcmV0dXJuIGxvY2tNYW5hZ2VyICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBhd2FpdCBsb2NrTWFuYWdlci5yZXF1ZXN0KGtleSwgY2FsbGJhY2spXG4gICAgICAgIDogYXdhaXQgbWFudWFsTXV0ZXgoa2V5LCBjYWxsYmFjayk7XG59XG5mdW5jdGlvbiBnZXRNdXRleFZhbHVlKGtleSkge1xuICAgIGlmIChnbG9iYWxUaGlzLl9fY29udmV4QXV0aE11dGV4ZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBnbG9iYWxUaGlzLl9fY29udmV4QXV0aE11dGV4ZXMgPSB7fTtcbiAgICB9XG4gICAgbGV0IG11dGV4ID0gZ2xvYmFsVGhpcy5fX2NvbnZleEF1dGhNdXRleGVzW2tleV07XG4gICAgaWYgKG11dGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZ2xvYmFsVGhpcy5fX2NvbnZleEF1dGhNdXRleGVzW2tleV0gPSB7XG4gICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nOiBudWxsLFxuICAgICAgICAgICAgd2FpdGluZzogW10sXG4gICAgICAgIH07XG4gICAgfVxuICAgIG11dGV4ID0gZ2xvYmFsVGhpcy5fX2NvbnZleEF1dGhNdXRleGVzW2tleV07XG4gICAgcmV0dXJuIG11dGV4O1xufVxuZnVuY3Rpb24gc2V0TXV0ZXhWYWx1ZShrZXksIHZhbHVlKSB7XG4gICAgZ2xvYmFsVGhpcy5fX2NvbnZleEF1dGhNdXRleGVzW2tleV0gPSB2YWx1ZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGVucXVldWVDYWxsYmFja0Zvck11dGV4KGtleSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBtdXRleCA9IGdldE11dGV4VmFsdWUoa2V5KTtcbiAgICBpZiAobXV0ZXguY3VycmVudGx5UnVubmluZyA9PT0gbnVsbCkge1xuICAgICAgICBzZXRNdXRleFZhbHVlKGtleSwge1xuICAgICAgICAgICAgY3VycmVudGx5UnVubmluZzogY2FsbGJhY2soKS5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0Q2IgPSBnZXRNdXRleFZhbHVlKGtleSkud2FpdGluZy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGdldE11dGV4VmFsdWUoa2V5KS5jdXJyZW50bHlSdW5uaW5nID0gbnVsbDtcbiAgICAgICAgICAgICAgICBzZXRNdXRleFZhbHVlKGtleSwge1xuICAgICAgICAgICAgICAgICAgICAuLi5nZXRNdXRleFZhbHVlKGtleSksXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmc6IG5leHRDYiA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGVucXVldWVDYWxsYmFja0Zvck11dGV4KGtleSwgbmV4dENiKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgd2FpdGluZzogW10sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2V0TXV0ZXhWYWx1ZShrZXksIHtcbiAgICAgICAgICAgIC4uLm11dGV4LFxuICAgICAgICAgICAgd2FpdGluZzogWy4uLm11dGV4LndhaXRpbmcsIGNhbGxiYWNrXSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gbWFudWFsTXV0ZXgoa2V5LCBjYWxsYmFjaykge1xuICAgIGNvbnN0IG91dGVyUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3Qgd3JhcHBlZENhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKClcbiAgICAgICAgICAgICAgICAudGhlbigodikgPT4gcmVzb2x2ZSh2KSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goKGUpID0+IHJlamVjdChlKSk7XG4gICAgICAgIH07XG4gICAgICAgIHZvaWQgZW5xdWV1ZUNhbGxiYWNrRm9yTXV0ZXgoa2V5LCB3cmFwcGVkQ2FsbGJhY2spO1xuICAgIH0pO1xuICAgIHJldHVybiBvdXRlclByb21pc2U7XG59XG5mdW5jdGlvbiBicm93c2VyQWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyPy4odHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gYnJvd3NlclJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcj8uKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNsaWVudC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@convex-dev/auth/dist/react/client.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@convex-dev/auth/dist/react/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@convex-dev/auth/dist/react/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConvexAuthProvider: () => (/* binding */ ConvexAuthProvider),\n/* harmony export */   useAuthActions: () => (/* binding */ useAuthActions),\n/* harmony export */   useAuthToken: () => (/* binding */ useAuthToken)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var convex_browser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! convex/browser */ \"(ssr)/./node_modules/convex/dist/esm/browser/index-node.js\");\n/* harmony import */ var convex_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! convex/react */ \"(ssr)/./node_modules/convex/dist/esm/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _client_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./client.js */ \"(ssr)/./node_modules/@convex-dev/auth/dist/react/client.js\");\n/**\n * React bindings for Convex Auth.\n *\n * @module\n */ /* __next_internal_client_entry_do_not_use__ useAuthActions,ConvexAuthProvider,useAuthToken auto */ \n\n\n\n\n/**\n * Use this hook to access the `signIn` and `signOut` methods:\n *\n * ```ts\n * import { useAuthActions } from \"@convex-dev/auth/react\";\n *\n * function SomeComponent() {\n *   const { signIn, signOut } = useAuthActions();\n *   // ...\n * }\n * ```\n */ function useAuthActions() {\n    return (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(_client_js__WEBPACK_IMPORTED_MODULE_4__.ConvexAuthActionsContext);\n}\n/**\n * Replace your `ConvexProvider` with this component to enable authentication.\n *\n * ```tsx\n * import { ConvexAuthProvider } from \"@convex-dev/auth/react\";\n * import { ConvexReactClient } from \"convex/react\";\n * import { ReactNode } from \"react\";\n *\n * const convex = new ConvexReactClient(/* ... *\\/);\n *\n * function RootComponent({ children }: { children: ReactNode }) {\n *   return <ConvexAuthProvider client={convex}>{children}</ConvexAuthProvider>;\n * }\n * ```\n */ function ConvexAuthProvider(props) {\n    const { client, storage, storageNamespace, replaceURL, children } = props;\n    const authClient = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)({\n        \"ConvexAuthProvider.useMemo[authClient]\": ()=>({\n                authenticatedCall (action, args) {\n                    return client.action(action, args);\n                },\n                unauthenticatedCall (action, args) {\n                    return new convex_browser__WEBPACK_IMPORTED_MODULE_1__.ConvexHttpClient(client.address).action(action, args);\n                },\n                verbose: client.options?.verbose\n            })\n    }[\"ConvexAuthProvider.useMemo[authClient]\"], [\n        client\n    ]);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_client_js__WEBPACK_IMPORTED_MODULE_4__.AuthProvider, {\n        client: authClient,\n        storage: storage ?? // Handle SSR, RN, Web, etc.\n        // Pretend we always have storage, the component checks\n        // it in first useEffect.\n        ( true ? undefined : 0),\n        storageNamespace: storageNamespace ?? client.address,\n        replaceURL: replaceURL ?? ((url)=>{\n            window.history.replaceState({}, \"\", url);\n        }),\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(convex_react__WEBPACK_IMPORTED_MODULE_2__.ConvexProviderWithAuth, {\n            client: client,\n            useAuth: _client_js__WEBPACK_IMPORTED_MODULE_4__.useAuth,\n            children: children\n        })\n    });\n}\n/**\n * Use this hook to access the JWT token on the client, for authenticating\n * your Convex HTTP actions.\n *\n * You should not pass this token to other servers (think of it\n * as an \"ID token\").\n *\n * ```ts\n * import { useAuthToken } from \"@convex-dev/auth/react\";\n *\n * function SomeComponent() {\n *   const token = useAuthToken();\n *   const onClick = async () => {\n *     await fetch(`${CONVEX_SITE_URL}/someEndpoint`, {\n *       headers: {\n *         Authorization: `Bearer ${token}`,\n *       },\n *     });\n *   };\n *   // ...\n * }\n * ```\n */ function useAuthToken() {\n    return (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(_client_js__WEBPACK_IMPORTED_MODULE_4__.ConvexAuthTokenContext);\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvbnZleC1kZXYvYXV0aC9kaXN0L3JlYWN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7Ozs7R0FJRztBQUkrQztBQUN1QjtBQUVsQjtBQU1sQztBQUdyQjs7Ozs7Ozs7Ozs7R0FXRyxDQUNHLFNBQVUsY0FBYztJQUM1QixPQUFPLGlEQUFVLENBQUMsZ0VBQXdCLENBQUMsQ0FBQztBQUM5QyxDQUFDO0FBRUQ7Ozs7Ozs7Ozs7Ozs7O0dBY0csQ0FDRyxTQUFVLGtCQUFrQixDQUFDLEtBMENsQztJQUNDLE1BQU0sRUFBRSxNQUFNLEVBQUUsT0FBTyxFQUFFLGdCQUFnQixFQUFFLFVBQVUsRUFBRSxRQUFRLEVBQUUsR0FBRyxLQUFLLENBQUM7SUFDMUUsTUFBTSxVQUFVLEdBQUcsOENBQU87a0RBQ3hCLEdBQUcsRUFBRSxDQUNIO2dCQUNFLGlCQUFpQixFQUFDLE1BQU0sRUFBRSxJQUFJO29CQUM1QixPQUFPLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDO2dCQUNyQyxDQUFDO2dCQUNELG1CQUFtQixFQUFDLE1BQU0sRUFBRSxJQUFJO29CQUM5QixPQUFPLElBQUksNERBQWdCLENBQUUsTUFBYyxDQUFDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sQ0FDekQsTUFBTSxFQUNOLElBQUksQ0FDTCxDQUFDO2dCQUNKLENBQUM7Z0JBQ0QsT0FBTyxFQUFHLE1BQWMsQ0FBQyxPQUFPLEVBQUUsT0FBTztjQUMxQztpREFDSDtRQUFDLE1BQU07S0FBQyxDQUNULENBQUM7SUFDRixPQUFPLHVEQUNKLG9EQUFZO1FBQ1gsTUFBTSxFQUFFLFVBQVU7UUFDbEIsT0FBTyxFQUNMLE9BQU8sSUFDUCw0QkFBNEI7UUFDNUIsdURBQXVEO1FBQ3ZELHlCQUF5QjtTQUN4QixLQUE2QixDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQVEsQ0FBWSxDQUFFO1FBRXJFLGdCQUFnQixFQUFFLGdCQUFnQixJQUFLLE1BQWMsQ0FBQyxPQUFPO1FBQzdELFVBQVUsRUFDUixVQUFVLEtBQ1QsQ0FBQyxHQUFHLEVBQUUsRUFBRTtZQUNQLE1BQU0sQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsR0FBRyxDQUFDLENBQUM7U0FDM0MsQ0FBQyxDQUFDO1FBQUEsVUFHSix1REFBQyxnRUFBc0I7WUFBQyxNQUFNLEVBQUUsTUFBTTtZQUFFLE9BQU8sRUFBRSwrQ0FBTztZQUFBLFVBQ3JELFFBQVE7UUFBQSxFQUNjO0lBQUEsRUFDWixDQUNoQjtBQUNILENBQUM7QUEwR0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FzQkcsQ0FDRyxTQUFVLFlBQVk7SUFDMUIsT0FBTyxpREFBVSxDQUFDLDhEQUFzQixDQUFDLENBQUM7QUFDNUMsQ0FBQyIsInNvdXJjZXMiOlsiL1VzZXJzL3NlYW5naWwvc3JjL3JlYWN0L2luZGV4LnRzeCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@convex-dev/auth/dist/react/index.js\n");

/***/ })

};
;